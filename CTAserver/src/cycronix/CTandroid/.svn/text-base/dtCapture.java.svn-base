
/*
   Copyright 2011 Erigo Technologies LLC

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

package cycronix.CTandroid;

// rbnbFile (adapted from FileWatch)
//watch a folder of files and if any updates, send its contents to RBNB
//Matt Miller 9/2010

// 11/2011:  added retain-state for Folder, Filter text fields

import java.io.File;
import java.util.Timer;
import java.util.TimerTask;

import android.app.Activity;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.view.*;
import android.view.View.OnClickListener;
import android.widget.EditText;
import android.widget.TextView;
import android.widget.ToggleButton;
import android.widget.RadioButton;
import android.util.Log;

import cycronix.CTandroid.R;
import com.rbnb.sapi.Source;
import com.rbnb.sapi.ChannelMap;
 
public class dtCapture extends Activity {

	private static final float updateInc = (float)1.0;		// update interval (sec)
	private static boolean Running=false;
	private static boolean Connected=false;
	
	private static String folderName = "/sdcard/DCIM/Camera/";
	private static String fileFilter = "*.jpg";
	private static String rbnbServer = "localhost:3333";
	private static final String TAG = "dtCapture";
	private static String PREFS_NAME="dtCapture_preferences";
	
	private static int iterCount=0;
	TextView tv;
	private Timer myTimer;
	public static Source source;
	private static long lastMod = 0;
	private RadioButton stopBtn, runBtn;
	private ToggleButton matchBtn, retainBtn;
	private EditText folderNameET, fileFilterET;

	//---------------------------------------------------------------------------------	
    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        
        // Restore preferences
        SharedPreferences settings = getSharedPreferences(PREFS_NAME, 0);
        folderName = settings.getString("folderName", folderName);
        fileFilter = settings.getString("fileFilter", fileFilter);
        
        setContentView(R.layout.main);
    	tv = (TextView)findViewById(R.id.myText);
    	if(tv != null) tv.setText("rbnbFile watching "+folderName);
    	
    	// get GUI objects
    	folderNameET = (EditText)findViewById(R.id.folderName);
    	fileFilterET = (EditText)findViewById(R.id.fileFilter);
		folderNameET.setText(folderName);
		fileFilterET.setText(fileFilter);
		
		myTimer = new Timer();
		myTimer.schedule(new TimerTask() {
			@Override public void run() { TimerMethod(); }
		}, 0,(int)(updateInc*1000.)); 		// check interval
		
        runBtn = (RadioButton)findViewById(R.id.RunButton);
        stopBtn = (RadioButton)findViewById(R.id.StopButton);
        runBtn.setOnClickListener(new OnClickListener() {
	        	@Override
	        	public void onClick(View v) {
	            	if(!Running) {
	            		pLog("Starting up...");
//	            		startSource();
		            	Running = true;
	            	}
	        	}
        	}
        );
        stopBtn.setOnClickListener(new OnClickListener() {
	        	@Override
	        	public void onClick(View v) {
	            	if(Running) {
	            		pLog("Shutting down...");
//	            		stopSource();
		            	Running = false;
	            	}
	        	}
	    	}   	
    	);
        matchBtn = (ToggleButton)findViewById(R.id.commonName);
        retainBtn = (ToggleButton)findViewById(R.id.retainFile);
    }
 
    @Override
    protected void onDestroy() {
  	  Log.d(TAG,"onDestroy");
        super.onDestroy();
        myTimer.cancel();
        
        // Save user preferences
        SharedPreferences settings = getSharedPreferences(PREFS_NAME, 0);
        SharedPreferences.Editor editor = settings.edit();
        editor.putString("folderName", folderName);
        editor.putString("fileFilter", fileFilter);
    }  
    
	//---------------------------------------------------------------------------------	
    private void startSource() {
		// open RBNB Source
    	try {
    		pLog("Connecting to: "+rbnbServer);
        	EditText etxt = (EditText)findViewById(R.id.sourceName);
        	String sName = etxt.getText().toString();
        	if(sName.length() <= 0) sName = TAG;
        	
		    source = new Source(1,"append",10000);
//		    source.CloseRBNBConnection();		// just to be sure?
		    source.OpenRBNBConnection(rbnbServer,sName);
		    Connected=true;
    	} catch (Exception e) {
			tv.setText("Failed to open RBNB Connection!"); // should pop up error
    		Log.e(TAG,"FAILED to Open RBNB Connection!");
			Log.e(TAG,Log.getStackTraceString(e));
			Running = false;
			return;
    	}
    	
	    String sname = source.GetClientName();
	    pLog("opened RBNB source: "+sname);
    }
    
	//---------------------------------------------------------------------------------	
    private void stopSource() {
	    source.Detach();
	    Connected=false;
    }
    
	//---------------------------------------------------------------------------------	
	private void FileWatch() {
	
		java.io.File file=null;
		
		try {
//			if(!Connected) startSource();	// startup may take a while to reload archives
			
			// get updated list of files
	    	folderName = folderNameET.getText().toString();
	    	fileFilter = fileFilterET.getText().toString();
	    	boolean dosuffix=false;
	    	if(fileFilter.contains("*")) {	// lazy file filtering, either *.suffix or all
	    		dosuffix=true;
	    		int windex = fileFilter.lastIndexOf("*");
	    		if(windex < (fileFilter.length()-1)) {
	    			dosuffix = true;
	    			fileFilter = fileFilter.substring(windex+1);
	    		}
	    	}
	    
			File folder = new File(folderName);
			File[] listOfFiles = folder.listFiles();
			String fileName;
//			Log.d(TAG,"folder: "+folderName+", nfile: "+listOfFiles.length);
			boolean initMod = (lastMod==0);		// initialization pass
//			Log.d(TAG,"matchBtn: "+matchBtn.isChecked());
			
			for(int i=0; i<listOfFiles.length; i++) {
				if(!listOfFiles[i].isFile()) continue;
				fileName = listOfFiles[i].getName();
//				Log.d(TAG,"fileName: "+fileName+", filter: "+fileFilter);
				if(dosuffix) {
					if(!fileName.endsWith(fileFilter)) continue;
				}
				else if(!fileName.equals(fileFilter)) continue;
				
				// define RBNB channels
				ChannelMap cMap = new ChannelMap();
				String rName = fileName;	// rbnb channel name
//				if(commonName) {
				if(matchBtn.isChecked()) {	// common name
					if(dosuffix) rName = TAG+fileFilter;
					else		 rName = TAG;
				} 
				cMap.Add(rName);
				
				file = new java.io.File(folderName+"/"+fileName); 
				
				long fileLength = file.length();
				if(fileLength <= 0) continue;
//				Log.d(TAG,"file: "+file+", size: "+fileLength);
	
				if(initMod) {	// avoid resend at startup
					if(lastMod < file.lastModified()) lastMod = file.lastModified();	
				} else	// do real work after first-pass established mod-times
				
				if(file.lastModified() > lastMod) {
					byte[] data;
					data = new byte[(int)(fileLength)];	// read file update
					java.io.FileInputStream fis = new java.io.FileInputStream(file);
					int nread = fis.read(data);
					if(nread > 0) {
						pLog("Put file: "+fileName+", rbnbChan: "+rName+", size: "+fileLength);
						cMap.PutDataAsByteArray(0, data);
						source.Flush(cMap);	
					}
					lastMod = file.lastModified();	
//					if(!retainFile) {
					if(retainBtn.isChecked()) {
						file.delete();
						pLog("Deleted source file: "+fileName);
					}
			    }
			}
		} catch (java.lang.Exception e) {
			Log.e(TAG,Log.getStackTraceString(e));
			startSource();		// presume it needs to reconnect?
		}
		
//		if(file != null) lastMod = file.lastModified();	// catch lastMod time after full sweep
	}

	//---------------------------------------------------------------------------------
	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
	    MenuInflater inflater = getMenuInflater();
	    inflater.inflate(R.layout.rbnb_menu, menu);
	    return true;
	}

	//---------------------------------------------------------------------------------	
	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
	    // Handle item selection
	    switch (item.getItemId()) {
	    case R.id.quit:
	    	pLog("Exiting!");
	        System.exit(0);  
	        return true;
	    default:
	        return super.onOptionsItemSelected(item);
	    }
	}

	//---------------------------------------------------------------------------------	
	private void TimerMethod()
	{
		//This method is called directly by the timer
		//and runs in the same thread as the timer.

		//We call the method that will work with the UI
		//through the runOnUiThread method.
		this.runOnUiThread(Timer_Tick);
	}

//---------------------------------------------------------------------------------
	private Runnable Timer_Tick = new Runnable() {
		public void run() {
		//This method runs in the same thread as the UI.    	       
			if(Running) {
//			if(runBtn.isChecked()) {
				stopBtn.setChecked(false); runBtn.setChecked(true);
				if(!Connected) startSource();	// do this async, may take a while
				FileWatch();
				iterCount++;
				tv.setText("Running: "+(int)(iterCount*updateInc));
			} else {
				if(Connected) stopSource();		// async
				if(iterCount > 0) {
					pLog("Stopped.");
					stopBtn.setChecked(true); runBtn.setChecked(false);
				}
				iterCount=0;
			}
		}
	};

//---------------------------------------------------------------------------------
	private void pLog(String msg) {
		tv.setText(msg);
		Log.d(TAG,msg);
	}
};
 

